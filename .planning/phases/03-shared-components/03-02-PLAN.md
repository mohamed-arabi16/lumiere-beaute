---
phase: 03-shared-components
plan: "02"
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - src/components/animations/FadeInSection.tsx
  - src/components/animations/StaggerContainer.tsx
autonomous: true
requirements:
  - SC3-1
  - SC3-3
  - SC3-5

must_haves:
  truths:
    - "Wrapping any JSX in FadeInSection causes it to fade and slide upward into view when scrolled to, once only"
    - "Wrapping a grid of items in StaggerContainer causes each child to animate in sequentially with 0.06s between each"
    - "Both components use viewport={{ once: true }} so content never re-animates on scroll-back"
  artifacts:
    - path: "src/components/animations/FadeInSection.tsx"
      provides: "Scroll-reveal wrapper using whileInView + vertical y translate"
      exports: ["FadeInSection"]
      min_lines: 25
    - path: "src/components/animations/StaggerContainer.tsx"
      provides: "Stagger orchestrator exporting the container and shared item variant"
      exports: ["StaggerContainer", "staggerItemVariants"]
      min_lines: 30
  key_links:
    - from: "src/components/animations/FadeInSection.tsx"
      to: "src/animations/variants.ts"
      via: "import fadeInUpVariants"
      pattern: "import.*fadeInUpVariants"
    - from: "src/components/animations/StaggerContainer.tsx"
      to: "src/animations/variants.ts"
      via: "import staggerContainerVariants and staggerItemVariants"
      pattern: "import.*staggerContainerVariants"
---

<objective>
Build the two scroll-reveal animation wrapper components — FadeInSection and StaggerContainer — that all page sections in Phase 4+ will use to animate content into view.

Purpose: These are the workhorses of the cinematic scroll experience. Every section on the homepage, services grid, testimonials, and academy cards will wrap its content in one of these two components.
Output: FadeInSection.tsx (single section reveal) and StaggerContainer.tsx (orchestrated multi-item reveal), both using whileInView with viewport once:true.
</objective>

<execution_context>
@/Users/mohamedkhair/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mohamedkhair/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/animations/variants.ts
@.planning/phases/03-shared-components/3-RESEARCH.md
@.planning/phases/03-shared-components/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FadeInSection scroll-reveal component</name>
  <files>src/components/animations/FadeInSection.tsx</files>
  <action>
    Create the directory `src/components/animations/` if it does not exist, then create `FadeInSection.tsx`.

    This component uses `whileInView` with a vertical-only (`y`) animation — NOT horizontal (`x`). The design decision from research: use `y` to avoid RTL complexity entirely; horizontal slides are reserved for page transitions (already implemented in Phase 2). A vertical fade-up matches the editorial luxury aesthetic without directional ambiguity.

    Implementation:
    ```tsx
    import { motion } from 'motion/react';
    import { fadeInUpVariants } from '../../animations/variants';

    interface FadeInSectionProps {
      children: React.ReactNode;
      className?: string;
      delay?: number;  // seconds; defaults to 0
    }

    export function FadeInSection({ children, className, delay = 0 }: FadeInSectionProps) {
      const variants = delay > 0
        ? {
            hidden: fadeInUpVariants.hidden,
            visible: {
              ...fadeInUpVariants.visible,
              transition: {
                ...(fadeInUpVariants.visible as { transition: object }).transition,
                delay,
              },
            },
          }
        : fadeInUpVariants;

      return (
        &lt;motion.div
          variants={variants}
          initial="hidden"
          whileInView="visible"
          viewport={{ once: true, amount: 0.2 }}
          className={className}
        &gt;
          {children}
        &lt;/motion.div&gt;
      );
    }
    ```

    Critical constraints:
    - `viewport={{ once: true }}` is REQUIRED — without it, the animation replays every time the user scrolls back up past the element, which looks broken.
    - `amount: 0.2` means the animation triggers when 20% of the element is visible — prevents triggering before content enters the viewport.
    - Import path `motion/react` matches the project convention (NOT `framer-motion`).
    - Import path `../../animations/variants` is correct relative to `src/components/animations/FadeInSection.tsx`.

    TypeScript note: the delay variant merging uses a cast on `fadeInUpVariants.visible` — if TypeScript complains, use `as any` on the transition spread or inline the transition object directly.
  </action>
  <verify>Run `npx tsc --noEmit` from /Users/mohamedkhair/Coding/lumiere-beaute — zero TypeScript errors. File exists at `src/components/animations/FadeInSection.tsx`. `grep "whileInView" src/components/animations/FadeInSection.tsx` returns a match. `grep "once: true" src/components/animations/FadeInSection.tsx` returns a match.</verify>
  <done>FadeInSection.tsx exists, TypeScript compiles cleanly, and the component uses whileInView with viewport once:true and amount:0.2.</done>
</task>

<task type="auto">
  <name>Task 2: Create StaggerContainer orchestration component</name>
  <files>src/components/animations/StaggerContainer.tsx</files>
  <action>
    Create `src/components/animations/StaggerContainer.tsx`.

    This component renders a `motion.div` that uses `whileInView` with `staggerChildren` to cascade animation across its direct children. Children must themselves be `motion.div` elements using `staggerItemVariants` (exported from this file for convenience).

    Implementation:
    ```tsx
    import { motion } from 'motion/react';
    import { staggerContainerVariants, staggerItemVariants as baseItemVariants } from '../../animations/variants';
    import type { Variants } from 'motion/react';

    // Re-export so page sections only need to import from this file
    export const staggerItemVariants: Variants = baseItemVariants;

    interface StaggerContainerProps {
      children: React.ReactNode;
      className?: string;
      staggerDelay?: number;  // seconds between children; default 0.06
    }

    export function StaggerContainer({
      children,
      className,
      staggerDelay = 0.06,
    }: StaggerContainerProps) {
      return (
        &lt;motion.div
          variants={staggerContainerVariants(staggerDelay)}
          initial="hidden"
          whileInView="visible"
          viewport={{ once: true, amount: 0.1 }}
          className={className}
        &gt;
          {children}
        &lt;/motion.div&gt;
      );
    }
    ```

    Critical constraints:
    - `viewport={{ once: true }}` is REQUIRED — same reason as FadeInSection.
    - `amount: 0.1` (not 0.2) — grids are often taller than their visible window, so a lower threshold ensures the stagger starts as soon as the top of the grid is visible.
    - Default `staggerDelay = 0.06` — with 20 cards at 0.06s, the last card begins at 1.14s, within the perceptual ~1s "animated" window. Do not use 0.1 or higher for large grids.
    - RTL note: CSS `dir="rtl"` on the html element causes the visual grid to flow right-to-left. Since stagger follows DOM order (which is left-to-right), the first DOM card is visually rightmost in Arabic — creating a right-to-left cascade. This is the correct reading-direction behavior. No JavaScript direction logic needed.

    Usage example for Phase 4 (document in file comment):
    ```tsx
    // Usage:
    // &lt;StaggerContainer className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6"&gt;
    //   {items.map(item => (
    //     &lt;motion.div key={item.id} variants={staggerItemVariants}&gt;
    //       &lt;Card {...item} /&gt;
    //     &lt;/motion.div&gt;
    //   ))}
    // &lt;/StaggerContainer&gt;
    ```
  </action>
  <verify>Run `npx tsc --noEmit` from /Users/mohamedkhair/Coding/lumiere-beaute — zero TypeScript errors. `grep "staggerItemVariants" src/components/animations/StaggerContainer.tsx` returns the export line. `grep "whileInView" src/components/animations/StaggerContainer.tsx` returns a match. `grep "once: true" src/components/animations/StaggerContainer.tsx` returns a match.</verify>
  <done>StaggerContainer.tsx exists, exports both StaggerContainer and staggerItemVariants, TypeScript compiles cleanly. The component uses whileInView with viewport once:true and amount:0.1.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors after both files are created
2. `npm run build` succeeds
3. Both files exist: `ls src/components/animations/` shows FadeInSection.tsx and StaggerContainer.tsx
4. `grep "once: true" src/components/animations/FadeInSection.tsx src/components/animations/StaggerContainer.tsx` — both files have once:true
5. `grep "export.*staggerItemVariants" src/components/animations/StaggerContainer.tsx` — export confirmed
</verification>

<success_criteria>
- FadeInSection.tsx: whileInView with vertical y-only animation, viewport once:true amount:0.2, delay prop supported
- StaggerContainer.tsx: whileInView with staggerChildren, viewport once:true amount:0.1, staggerDelay prop defaults to 0.06, re-exports staggerItemVariants
- Both components import from motion/react and ../../animations/variants
- TypeScript build remains clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-shared-components/03-02-SUMMARY.md`
</output>
